.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::RangeHash 3"
.TH Tie::RangeHash 3 "2017-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::RangeHash \- Allows hashes to associate values with a range of keys
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Algorithm::SkipList is required.  Otherwise it uses
standard modules.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Tie::RangeHash;
\&
\&  tie %hash, \*(AqTie::RangeHash\*(Aq;
\&
\&  $hash{\*(AqA,C\*(Aq} = 1;
\&  $hash{\*(AqD,F\*(Aq} = 2;
\&  $hash{\*(AqG,K\*(Aq} = 3;
\&
\&  $hash{\*(AqE\*(Aq};           # returns \*(Aq2\*(Aq
\&  $hash{\*(AqBB\*(Aq};          # returns \*(Aq1\*(Aq
\&
\&  $hash{\*(AqKL\*(Aq};          # returns nothing (\*(Aqundef\*(Aq)
.Ve
.PP
There is also an object-oriented interface:
.PP
.Vb 1
\&  $hash = new Tie::RangeHash;
\&
\&  $hash\->add(\*(AqA,C\*(Aq, 1);
\&  $hash\->add(\*(AqG,I\*(Aq, 2);
\&
\&  $hash\->fetch(\*(AqH\*(Aq);    # returns \*(Aq2\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows hashes to associate a value with a \fIrange\fR of keys rather
than a single key.
.PP
For example, you could pass date ranges to the hash and then query it with
a specific date, like so:
.PP
.Vb 3
\&  $cost{\*(Aq1999\-12\-15,2000\-01\-14\*(Aq} = 150;
\&  $cost{\*(Aq2000\-01\-15,2000\-02\-14\*(Aq} = 103;
\&  $cost{\*(Aq2000\-02\-15,2000\-03\-14\*(Aq} =  97;
.Ve
.PP
and then query the cost on a specific date:
.PP
.Vb 1
\&  $this_cost = $cost{\*(Aq2000\-02\-08\*(Aq};
.Ve
.PP
Numeric key ranges can also be used:
.PP
.Vb 3
\&  tie %hash, \*(AqTie::RangeHash\*(Aq, {
\&    Type => Tie::RangeHash::TYPE_NUMBER
\&  };
\&
\&  $hash{\*(Aq1.4,1.8\*(Aq}      = \*(AqJim\*(Aq;
\&  $hash{\*(Aq1.0,1.399999\*(Aq} = \*(AqNed\*(Aq;
\&  $hash{\*(Aq1.800001,2.0\*(Aq} = \*(AqBoo\*(Aq;
.Ve
.PP
Custom comparison routines to support alternate datatypes can be
implemented by specifying a new node type for Algorithm::SkipList.
.SS "Object-Oriented Interface"
.IX Subsection "Object-Oriented Interface"
Tie::RangeHash has an object-oriented interface as an alternative to
using a tied hash.
.IP "new" 4
.IX Item "new"
Creates a new object.
.Sp
.Vb 1
\&  $obj = Tie::RangeHash\->new( %attr );
.Ve
.Sp
\&\f(CW%attr\fR is a hash containing the attributes described above.
.IP "add" 4
.IX Item "add"
Adds a new key/value pair to the object.
.Sp
.Vb 1
\&  $obj\->add( $key, $value );
.Ve
.Sp
\&\f(CW$key\fR may be a string value in the form of \f(CW\*(C`low,high\*(C'\fR (for example,
\&\*(L"Samantha,Selma\*(R").
.IP "fetch" 4
.IX Item "fetch"
.Vb 1
\&  $value = $obj\->fetch( $key );
.Ve
.Sp
Returns the value associated with \f(CW$key\fR. (\f(CW$key\fR may be in the form of
\&\f(CW\*(C`low,high\*(C'\fR or any key between \f(CW\*(C`low\*(C'\fR and \f(CW\*(C`high\*(C'\fR.)
.Sp
If they key range overlaps multiple keys, it will return a fatal
error.  In such cases, use \*(L"fetch_overlap\*(R".
.IP "fetch_overlap" 4
.IX Item "fetch_overlap"
.Vb 1
\&  @values = $obj\->fetch_overlap("$low,$high");
.Ve
.Sp
Retrieves multiple values associated with a range of keys between \f(CW$low\fR
and \f(CW$high\fR.  Capable of fetching values from overlapping keys.
.Sp
See \*(L"\s-1KNOWN ISSUES\*(R"\s0 for more information about overlapping keys.
.IP "fetch_key" 4
.IX Item "fetch_key"
.Vb 1
\&  $real_key = $obj\->fetch_key( $key );
\&
\&  ($real_key, $value) = $obj\->fetch( $key );
.Ve
.Sp
Like \*(L"fetch\*(R", but it returns the \fIkey range\fR that was matched rather
than the value. If it is called in an array context, it will return the
key and value.
.IP "key_exists" 4
.IX Item "key_exists"
.Vb 1
\&  if ($obj\->key_exists( $key )) { .. }
.Ve
.Sp
Returns c<true> if \f(CW$key\fR has been defined (even if the value is \f(CW\*(C`undef\*(C'\fR).
(\f(CW$key\fR is in the same form as is used by the \*(L"fetch\*(R" method.)
.IP "clear" 4
.IX Item "clear"
.Vb 1
\&  $obj\->clear();
.Ve
.Sp
Deletes all keys and values defined in the object.
.IP "remove" 4
.IX Item "remove"
.Vb 1
\&  $value = $obj\->remove( $key );
.Ve
.Sp
Deletes the \f(CW$key\fR from the object and returnes the associated value.
(\f(CW$key\fR is in the same form as is used by the \f(CW\*(C`fetch\*(C'\fR method.)  If
\&\f(CW$key\fR is not the exact \f(CW\*(C`low,high\*(C'\fR range, a warning will be emitted.
.IP "first_key" 4
.IX Item "first_key"
.Vb 1
\&  $key = $obj\->first_key();
.Ve
.Sp
Returns the first.
.IP "next_key" 4
.IX Item "next_key"
.Vb 1
\&  $key = $obj\->next_key($last_key);
.Ve
.Sp
Returns the next key in the iteration.
.SS "Implementation Notes"
.IX Subsection "Implementation Notes"
Internally, the hash uses skip lists.  Skip lists are an alternative
to binary trees.  For more information, see Algorithm::SkipList.
.PP
Future versions may be changed to use something else that is more
efficient.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
The is a new version of the module and has behaves differently
compared to older versions.  This is due to using the
Algorithm::SkipList module for maintaining the underlying data rather
than re-implementing it.  While this improves the maintainability with
the code, it increases incompatability with previous versions.
.PP
Some of the changes include:
.IP "Overlapping keys cause fatal errors instead of warnings" 4
.IX Item "Overlapping keys cause fatal errors instead of warnings"
Because the key comparison is now performed in the skip list node,
there is no obvious way for it to give a warning and return a
meaningful result.  So instead the code dies.  If you code relies on
the possibility of using overlapping keys, then it may be more
appropriate to have it test the code:
.Sp
.Vb 3
\&  eval {
\&    $hash{\*(Aq111,999\*(Aq} = $value;
\&  };
.Ve
.Sp
This error can also occur by merely testing a hash, so it is important
to run some checks if you are testing hash ranges:
.Sp
.Vb 3
\&  eval {
\&    if ($hash{\*(Aq111,999\*(Aq} == $value) { ... }
\&  }
.Ve
.Sp
Another option is to use \*(L"fetch_overlap\*(R" instead.
.IP "Keys can be redefined" 4
.IX Item "Keys can be redefined"
Nodes can now be redefined.  For example:
.Sp
.Vb 5
\&  $hash{\*(Aq1,3\*(Aq} = $value;
\&  ...
\&  $hash{\*(Aq1,3\*(Aq} = $new_value;
\&  ...
\&  $hash{\*(Aq2\*(Aq}   = $new_value;
.Ve
.Sp
Note that a range is no longer required.
.IP "Non-range keys can be added." 4
.IX Item "Non-range keys can be added."
When inserting a key, \f(CW$hash{\*(Aqx\*(Aq}\fR will be treated like \f(CW$hash{\*(Aqx,x\*(Aq}\fR.
.IP "Open-ended ranges are allowed." 4
.IX Item "Open-ended ranges are allowed."
Open ended ranges are now supported.  So the following can be added:
.Sp
.Vb 2
\&  $hash{\*(Aq,10\*(Aq} = $upper_bound;
\&  $hash{\*(Aq11,\*(Aq} = $lower_bound;
.Ve
.Sp
Note that once open-ended ranges are defined, they are permenently
open-ended unless the final range is deleted.  Thus,
.Sp
.Vb 1
\&  $hash{\*(Aq12,13\*(Aq}
.Ve
.Sp
refers to the key \f(CW"11,"\fR.
.IP "Array references can no longer be keys." 4
.IX Item "Array references can no longer be keys."
The following is \fInot\fR supported anymore:
.Sp
.Vb 1
\&  $hash{ \e@array ) = $value;
.Ve
.IP "warnings no longer registered." 4
.IX Item "warnings no longer registered."
Warning registration is no longer used.  This may change in the future.
.IP "Custom separators and comparisons are not supported." 4
.IX Item "Custom separators and comparisons are not supported."
Only commas can be used as separators.
.Sp
To customize separators and comparisons, you will have to specify a
custom \f(CW\*(C`Algorithm::SkipList::Node\*(C'\fR method.
.PP
See the Changes file for a more complete list of changes and
incompatabilities.
.PP
If your code does not rely on these quirks, then you should be able to
substitute with no problems.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
A module with similar functionality for numerical values is Array::IntSpan.
.PP
Algorithm::SkipList for more information on skip lists.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robert Rothenberg <rrwo at cpan.org>
.SS "Acknowledgements"
.IX Subsection "Acknowledgements"
Charles Huff <charleshuff atdecisionresearch.com> for suggestions and
bug reports.
.PP
Sam Tregar <sam at tregar.com> for optimization suggestions.
.PP
Various Perl Monks <http://www.perlmonks.org> for advice and code snippets.
.SS "Suggestions and Bug Reporting"
.IX Subsection "Suggestions and Bug Reporting"
Feedback is always welcome.  Please use the \s-1CPAN\s0 Request Tracker at
<http://rt.cpan.org> to submit bug reports.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2000\-2008 Robert Rothenberg. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
