.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Algorithm::SkipList 3"
.TH Algorithm::SkipList 3 "2017-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Algorithm::SkipList \- Perl implementation of skip lists
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
The following non-standard modules are used:
.PP
.Vb 1
\&  enum
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $list = new Algorithm::SkipList();
\&
\&  $list\->insert( \*(Aqkey1\*(Aq, \*(Aqvalue\*(Aq );
\&  $list\->insert( \*(Aqkey2\*(Aq, \*(Aqanother value\*(Aq );
\&
\&  $value = $list\->find(\*(Aqkey2\*(Aq);
\&
\&  $list\->delete(\*(Aqkey1\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an implementation of \fIskip lists\fR in Perl.
.PP
Skip lists are similar to linked lists, except that they have random
links at various \fIlevels\fR that allow searches to skip over sections
of the list, like so:
.PP
.Vb 8
\&  4 +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> +
\&    |                             |                        |
\&  3 +\-\-\-\-\-\-\-\-\-\-\-\-> +\-\-\-\-\-\-\-\-\-\-\-\-> +\-\-\-\-\-\-\-> +\-\-\-\-\-\-\-> +\-\-> +
\&    |              |              |         |         |    |
\&  2 +\-\-\-\-\-\-\-> +\-\-> +\-\-\-\-\-\-\-> +\-\-> +\-\-> +\-\-> +\-\-\-\-\-\-\-> +\-\-> +
\&    |         |    |         |    |    |    |         |    |
\&  1 +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +\-\-> +
\&         A    B    C    D    E    F    G    H    I    J   NIL
.Ve
.PP
A search would start at the top level: if the link to the right
exceeds the target key, then it descends a level.
.PP
Skip lists generally perform as well as balanced trees for searching
but do not have the overhead with respect to inserting new items.  See
the included file \f(CW\*(C`Benchmark.txt\*(C'\fR for a comparison of performance
with other Perl modules.
.PP
For more information on skip lists, see the \*(L"\s-1SEE ALSO\*(R"\s0 section below.
.PP
Only alphanumeric keys are supported \*(L"out of the box\*(R".  To use numeric
or other types of keys, see \*(L"Customizing the Node Class\*(R" below.
.SS "Methods"
.IX Subsection "Methods"
A detailed description of the methods used is below.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $list = new Algorithm::SkipList();
.Ve
.Sp
Creates a new skip list.
.Sp
If you need to use a different node class for using
customized comparison routines, you will need to specify a
different class:
.Sp
.Vb 1
\&  $list = new Algorithm::SkipList( node_class => \*(AqMyNodeClass\*(Aq );
.Ve
.Sp
See the \*(L"Customizing the Node Class\*(R" section below.
.Sp
Specialized internal parameters may be configured:
.Sp
.Vb 1
\&  $list = new Algorithm::SkipList( max_level => 32 );
.Ve
.Sp
Defines a different maximum list level.
.Sp
The initial list (see the \*(L"list\*(R" method) will be a
random number of levels, and will increase over
time if inserted nodes have higher levels, up until \*(L"max_level\*(R"
levels.  See \*(L"max_level\*(R" for more information on this parameter.
.Sp
You can also control the probability used to determine level sizes for
each node by setting the P and k values:
.Sp
.Vb 1
\&  $list = new Algorithm::SkipList( p => 0.25, k => 1 );
.Ve
.Sp
See  P for more information on this parameter.
.Sp
You can enable duplicate keys by using the following:
.Sp
.Vb 1
\&  $list = new Algorithm::SkipList( duplicates => 1 );
.Ve
.Sp
This is an experimental feature. See the \*(L"\s-1KNOWN ISSUES\*(R"\s0 section
below.
.IP "insert" 4
.IX Item "insert"
.Vb 1
\&  $list\->insert( $key, $value );
.Ve
.Sp
Inserts a new node into the list.
.Sp
You may also use a search finger with insert,
provided that the finger is for a key that occurs earlier in the list:
.Sp
.Vb 1
\&  $list\->insert( $key, $value, $finger );
.Ve
.Sp
Using fingers for inserts is \fInot\fR recommended since there is a risk
of producing corrupted lists.
.IP "exists" 4
.IX Item "exists"
.Vb 1
\&  if ($list\->exists( $key )) { ... }
.Ve
.Sp
Returns true if there exists a node associated with the key, false
otherwise.
.Sp
This may also be used with  search fingers:
.Sp
.Vb 1
\&  if ($list\->exists( $key, $finger )) { ... }
.Ve
.IP "find_with_finger" 4
.IX Item "find_with_finger"
.Vb 1
\&  $value = $list\->find_with_finger( $key );
.Ve
.Sp
Searches for the node associated with the key, and returns the value. If
the key cannot be found, returns \f(CW\*(C`undef\*(C'\fR.
.Sp
Search fingers may also be used:
.Sp
.Vb 1
\&  $value = $list\->find_with_finger( $key, $finger );
.Ve
.Sp
To obtain the search finger for a key, call \*(L"find_with_finger\*(R" in a
list context:
.Sp
.Vb 1
\&  ($value, $finger) = $list\->find_with_finger( $key );
.Ve
.IP "find" 4
.IX Item "find"
.Vb 1
\&  $value = $list\->find( $key );
\&
\&  $value = $list\->find( $key, $finger );
.Ve
.Sp
Searches for the node associated with the key, and returns the value. If
the key cannot be found, returns \f(CW\*(C`undef\*(C'\fR.
.Sp
This method is slightly faster than \*(L"find_with_finger\*(R" since it does
not return a search finger when called in list context.
.Sp
If you are searching for duplicate keys, you must use
\&\*(L"find_with_finger\*(R" or \*(L"find_duplicates\*(R".
.IP "find_duplicates" 4
.IX Item "find_duplicates"
.Vb 1
\&  @values = $list\->find_duplicates( $key );
\&
\&  @values = $list\->find_duplicates( $key, $finger );
.Ve
.Sp
Returns an array of values from the list.
.Sp
This is an autoloading method.
.IP "search" 4
.IX Item "search"
Search is an alias to \*(L"find\*(R".
.IP "first_key" 4
.IX Item "first_key"
.Vb 1
\&  $key = $list\->first_key;
.Ve
.Sp
Returns the first key in the list.
.Sp
If called in a list context, will return a
search finger:
.Sp
.Vb 1
\&  ($key, $finger) = $list\->first_key;
.Ve
.Sp
A call to \*(L"first_key\*(R" implicitly calls \*(L"reset\*(R".
.IP "next_key" 4
.IX Item "next_key"
.Vb 1
\&  $key = $list\->next_key( $last_key );
.Ve
.Sp
Returns the key following the previous key.  List nodes are always
maintained in sorted order.
.Sp
Search fingers may also be used to improve performance:
.Sp
.Vb 1
\&  $key = $list\->next_key( $last_key, $finger );
.Ve
.Sp
If called in a list context, will return a
search finger:
.Sp
.Vb 1
\&  ($key, $finger) = $list\->next_key( $last_key, $finger );
.Ve
.Sp
If no arguments are called,
.Sp
.Vb 1
\&  $key = $list\->next_key;
.Ve
.Sp
then the value of \*(L"last_key\*(R" is assumed:
.Sp
.Vb 1
\&  $key = $list\->next_key( $list\->last_key );
.Ve
.Sp
Note: calls to \*(L"delete\*(R" will \*(L"reset\*(R" the last key.
.IP "next" 4
.IX Item "next"
.Vb 1
\&  ($key, $value) = $list\->next( $last_key, $finger );
.Ve
.Sp
Returns the next key-value pair.
.Sp
\&\f(CW$last_key\fR and \f(CW$finger\fR are optional.
.Sp
This is an autoloading method.
.IP "last_key" 4
.IX Item "last_key"
.Vb 1
\&  $key = $list\->last_key;
\&
\&  ($key, $finger, $value) = $list\->last_key;
.Ve
.Sp
Returns the last key or the last key and finger returned by a call to
\&\*(L"first_key\*(R", \*(L"next_key\*(R", \*(L"index_by_key\*(R", \*(L"key_by_index\*(R" or
\&\*(L"value_by_index\*(R".  This is not the greatest key.
.Sp
Deletions and inserts may invalidate the \*(L"last_key\*(R" value.
(Deletions will actually \*(L"reset\*(R" the value.)
.Sp
Values for \*(L"last_key\*(R" can also be set by including parameters,
however this feature is meant for \fIinternal use only\fR:
.Sp
.Vb 1
\&  $list\->last_key( $node );
.Ve
.Sp
Note that this is a change form versions prior to 0.71.
.IP "reset" 4
.IX Item "reset"
.Vb 1
\&  $list\->reset;
.Ve
.Sp
Resets the \*(L"last_key\*(R" to \f(CW\*(C`undef\*(C'\fR.
.IP "index_by_key" 4
.IX Item "index_by_key"
.Vb 1
\&  $index = $list\->index_by_key( $key );
.Ve
.Sp
Returns the 0\-based index of the key (as if the list were an array).
\&\fIThis is not an efficient method of access.\fR
.Sp
This is an autoloading method.
.IP "key_by_index" 4
.IX Item "key_by_index"
.Vb 1
\&  $key = $list\->key_by_index( $index );
.Ve
.Sp
Returns the key associated with an index (as if the list were an
array).  Negative indices return the key from the end.  \fIThis is not
an efficient method of access.\fR
.Sp
This is an autoloading method.
.IP "value_by_index" 4
.IX Item "value_by_index"
.Vb 1
\&  $value = $list\->value_by_index( $index );
.Ve
.Sp
Returns the value associated with an index (as if the list were an
array).  Negative indices return the value from the end.  \fIThis is not
an efficient method of access.\fR
.Sp
This is an autoloading method.
.IP "delete" 4
.IX Item "delete"
.Vb 1
\&  $value = $list\->delete( $key );
.Ve
.Sp
Deletes the node associated with the key, and returns the value.  If
the key cannot be found, returns \f(CW\*(C`undef\*(C'\fR.
.Sp
Search fingers may also be used:
.Sp
.Vb 1
\&  $value = $list\->delete( $key, $finger );
.Ve
.Sp
Calling \*(L"delete\*(R" in a list context \fIwill not\fR return a search
finger.
.IP "clear" 4
.IX Item "clear"
.Vb 1
\&  $list\->clear;
.Ve
.Sp
Erases existing nodes and resets the list.
.IP "size" 4
.IX Item "size"
.Vb 1
\&  $size = $list\->size;
.Ve
.Sp
Returns the number of nodes in the list.
.IP "copy" 4
.IX Item "copy"
.Vb 1
\&  $list2 = $list1\->copy;
.Ve
.Sp
Makes a copy of a list.  The \*(L"p\*(R", \*(L"max_level\*(R" and
node class are copied, although the exact structure of node
levels is not copied.
.Sp
.Vb 1
\&  $list2 = $list1\->copy( $key_from, $finger, $key_to );
.Ve
.Sp
Copy the list between \f(CW$key_from\fR and \f(CW$key_to\fR (inclusive).  If
\&\f(CW$finger\fR is defined, it will be used as a search finger to find
\&\f(CW$key_from\fR.  If \f(CW$key_to\fR is not specified, then it will be assumed
to be the end of the list.
.Sp
If \f(CW$key_from\fR does not exist, \f(CW\*(C`undef\*(C'\fR will be returned.
.Sp
This is an autoloading method.
.IP "merge" 4
.IX Item "merge"
.Vb 1
\&  $list1\->merge( $list2 );
.Ve
.Sp
Merges two lists.  If both lists share the same key, then the valie
from \f(CW$list1\fR will be used.
.Sp
Both lists should have the same node class.
.Sp
This is an autoloading method.
.IP "append" 4
.IX Item "append"
.Vb 1
\&  $list1\->append( $list2 );
.Ve
.Sp
Appends (concatenates) \f(CW$list2\fR after \f(CW$list1\fR.  The last key of
\&\f(CW$list1\fR must be less than the first key of \f(CW$list2\fR.
.Sp
Both lists should have the same node class.
.Sp
This method affects both lists.  The \*(L"header\*(R" of the last node of
\&\f(CW$list1\fR points to the first node of \f(CW$list2\fR, so changes to one
list may affect the other list.
.Sp
If you do not want this entanglement, use the \*(L"merge\*(R" or \*(L"copy\*(R"
methods instead:
.Sp
.Vb 1
\&  $list1\->merge( $list2 );
.Ve
.Sp
or
.Sp
.Vb 1
\&  $list1\->append( $list2\->copy );
.Ve
.Sp
This is an autoloading method.
.IP "truncate" 4
.IX Item "truncate"
.Vb 1
\&  $list2 = $list1\->truncate( $key );
.Ve
.Sp
Truncates \f(CW$list1\fR and returns \f(CW$list2\fR starting at \f(CW$key\fR.
Returns \f(CW\*(C`undef\*(C'\fR is the key does not exist.
.Sp
It is asusmed that the key is not the first key in \f(CW$list1\fR.
.Sp
This is an autoloading method.
.IP "least" 4
.IX Item "least"
.Vb 1
\&  ($key, $value) = $list\->least;
.Ve
.Sp
Returns the least key and value in the list, or \f(CW\*(C`undef\*(C'\fR if the list
is empty.
.Sp
This is an autoloading method.
.IP "greatest" 4
.IX Item "greatest"
.Vb 1
\&  ($key, $value) = $list\->greatest;
.Ve
.Sp
Returns the greatest key and value in the list, or \f(CW\*(C`undef\*(C'\fR if the list
is empty.
.Sp
This is an autoloading method.
.IP "keys" 4
.IX Item "keys"
.Vb 1
\&  @keys = $list\->keys;
.Ve
.Sp
Returns a list of keys (in sorted order).
.Sp
.Vb 1
\&  @keys = $list\->keys( $low, $high);
.Ve
.Sp
Returns a list of keys between \f(CW$low\fR and \f(CW$high\fR, inclusive. (This
is only available in versions 1.02 and later.)
.Sp
This is an autoloading method.
.IP "values" 4
.IX Item "values"
.Vb 1
\&  @values = $list\->values;
.Ve
.Sp
Returns a list of values (corresponding to the keys returned by the
\&\*(L"keys\*(R" method).
.Sp
This is an autoloading method.
.SS "Internal Methods"
.IX Subsection "Internal Methods"
Internal methods are documented below. These are intended for
developer use only.  These may change in future versions.
.IP "_search_with_finger" 4
.IX Item "_search_with_finger"
.Vb 1
\&  ($node, $finger, $cmp) = $list\->_search_with_finger( $key );
.Ve
.Sp
Searches for the node with a key.  If the key is found, that node is
returned along with a \*(L"header\*(R".  If the key is not found, the previous
node from where the node would be if it existed is returned.
.Sp
Note that the value of \f(CW$cmp\fR
.Sp
.Vb 1
\&  $cmp = $node\->key_cmp( $key )
.Ve
.Sp
is returned because it is already determined by \*(L"_search\*(R".
.Sp
Search fingers may also be specified:
.Sp
.Vb 1
\&  ($node, $finger, $cmp) = $list\->_search_with_finger( $key, $finger );
.Ve
.Sp
Note that the \*(L"header\*(R" is actually a
search finger.
.IP "_search" 4
.IX Item "_search"
.Vb 1
\&  ($node, $finger, $cmp) = $list\->_search( $key, [$finger] );
.Ve
.Sp
Same as \*(L"_search_with_finger\*(R", only that a search finger is not returned.
(Actually, an initial \*(L"dummy\*(R" finger is returned.)
.Sp
This is useful for searches where a finger is not needed.  The speed
of searching is improved.
.IP "k" 4
.IX Item "k"
.Vb 1
\&  $k = $list\->k;
.Ve
.Sp
Returns the \fIk\fR value.
.Sp
.Vb 1
\&  $list\->k( $k );
.Ve
.Sp
Sets the \fIk\fR value.
.Sp
Higher values will on the average have less pointers per node, but
take longer for searches.  See the section on the P value.
.IP "p" 4
.IX Item "p"
.Vb 1
\&  $plevel = $list\->p;
.Ve
.Sp
Returns the \fIP\fR value.
.Sp
.Vb 1
\&  $list\->p( $plevel );
.Ve
.Sp
Changes the value of \fIP\fR.  Lower values will on the average have less
pointers per node, but will take longer for searches.
.Sp
The probability that a particular node will have a forward pointer at
level \fIi\fR is: \fIp**(i+k\-1)\fR.
.Sp
For more information, consult the references below in the
\&\*(L"\s-1SEE ALSO\*(R"\s0 section.
.IP "max_level" 4
.IX Item "max_level"
.Vb 1
\&  $max = $list\->max_level;
.Ve
.Sp
Returns the maximum level that \*(L"_new_node_level\*(R" can generate.
.Sp
.Vb 3
\&  eval {
\&    $list\->max_level( $level );
\&  };
.Ve
.Sp
Changes the maximum level.  If level is less than \*(L"\s-1MIN_LEVEL\*(R"\s0, or
greater than \*(L"\s-1MAX_LEVEL\*(R"\s0 or the current list \*(L"level\*(R", this will fail
(hence the need for setting it in an \f(CW\*(C`eval\*(C'\fR block).
.Sp
The value defaults to \*(L"\s-1MAX_LEVEL\*(R"\s0, which is 32.  There is usually no
need to change this value, since the maximum level that a new node
will have will not be greater than it actually needs, up until 2^32
nodes.  (The current version of this module is not designed to handle
lists larger than 2^32 nodes.)
.Sp
Decreasing the maximum level to less than is needed will likely
degrade performance.
.IP "_new_node_level" 4
.IX Item "_new_node_level"
.Vb 1
\&  $level = $list\->_new_node_level;
.Ve
.Sp
This is an internal function for generating a random level for new nodes.
.Sp
Levels are determined by the P value.  The probability that a
node will have 1 level is \fIP\fR; the probability that a node will have
2 levels is \fIP^2\fR; the probability that a node will have 3 levels is
\&\fIP^3\fR, et cetera.
.Sp
The value will never be greater than \*(L"max_level\*(R".
.Sp
Note: in earlier versions it was called \f(CW\*(C`_random_level\*(C'\fR.
.IP "list" 4
.IX Item "list"
.Vb 1
\&  $node = $list\->list;
.Ve
.Sp
Returns the initial node in the list, which is a
\&\f(CW\*(C`Algorithm::SkipList::Node\*(C'\fR (See below.)
.Sp
The key and value for this node are undefined.
.IP "_first_node" 4
.IX Item "_first_node"
.Vb 1
\&  $node = $list\->_first_node;
.Ve
.Sp
Returns the first node with a key (the second node) in a list.  This
is used by the \*(L"first_key\*(R", \*(L"least\*(R", \*(L"append\*(R" and \*(L"merge\*(R"
methods.
.IP "_greatest_node" 4
.IX Item "_greatest_node"
.Vb 1
\&  $node = $list\->_greatest_node;
.Ve
.Sp
Returns the last node in the list.  This is used by the \*(L"append\*(R" and
\&\*(L"greatest\*(R" methods.
.IP "_node_class" 4
.IX Item "_node_class"
.Vb 1
\&  $node_class_name = $list\->_node_class;
.Ve
.Sp
Returns the name of the node class used.  By default this is the
\&\f(CW\*(C`Algorithm::SkipList::Node\*(C'\fR, which is discussed below.
.IP "_build_distribution" 4
.IX Item "_build_distribution"
.Vb 1
\&  $list\->_build_distribution;
.Ve
.Sp
Rebuilds the probability distribution array \f(CW\*(C`{P_LEVELS}\*(C'\fR upon calls
to \*(L"_set_p\*(R" and \*(L"_set_k\*(R".
.IP "_set_node_class" 4
.IX Item "_set_node_class"
.PD 0
.IP "_set_max_level" 4
.IX Item "_set_max_level"
.IP "_set_p" 4
.IX Item "_set_p"
.IP "_set_k" 4
.IX Item "_set_k"
.PD
These methods are used during initialization of the object.
.IP "_debug" 4
.IX Item "_debug"
.Vb 1
\&  $list\->_debug;
.Ve
.Sp
Used for debugging skip lists by developer.  The output of this
function is subject to change.
.SS "Node Methods"
.IX Subsection "Node Methods"
Methods for the Algorithm::SkipList::Node object are documented in
that module.  They are for internal use by the main
\&\f(CW\*(C`Algorithm::SkipList\*(C'\fR module.
.SH "SPECIAL FEATURES"
.IX Header "SPECIAL FEATURES"
.SS "Tied Hashes"
.IX Subsection "Tied Hashes"
Hashes can be tied to \f(CW\*(C`Algorithm::SkipList\*(C'\fR objects:
.PP
.Vb 2
\&  tie %hash, \*(AqAlgorithm::SkipList\*(Aq;
\&  $hash{\*(Aqfoo\*(Aq} = \*(Aqbar\*(Aq;
\&
\&  $list = tied %hash;
\&  print $list\->find(\*(Aqfoo\*(Aq); # returns bar
.Ve
.PP
See the perltie manpage for more information.
.SS "Customizing the Node Class"
.IX Subsection "Customizing the Node Class"
The default node may not handle specialized data types.  To define
your own custom class, you need to derive a child class from
\&\f(CW\*(C`Algorithm::SkipList::Node\*(C'\fR.
.PP
Below is an example of a node which redefines the default type to use
numeric instead of string comparisons:
.PP
.Vb 1
\&  package NumericNode;
\&
\&  our @ISA = qw( Algorithm::SkipList::Node );
\&
\&  sub key_cmp {
\&    my $self = shift;
\&
\&    my $left  = $self\->key;  # node key
\&    my $right = shift;       # value to compare the node key with
\&
\&    unless ($self\->validate_key($right)) {
\&      die "Invalid key: \e\*(Aq$right\e\*(Aq"; }
\&
\&    return ($left <=> $right);
\&  }
\&
\&  sub validate_key {
\&    my $self = shift;
\&    my $key  = shift;
\&    return ($key =~ s/\e\-?\ed+(\e.\ed+)?$/); # test if key is numeric
\&  }
.Ve
.PP
To use this, we say simply
.PP
.Vb 1
\&  $number_list = new Algorithm::SkipList( node_class => \*(AqNumericNode\*(Aq );
.Ve
.PP
This skip list should work normally, except that the keys must be
numbers.
.PP
For another example of customized nodes, see Tie::RangeHash version
1.00_b1 or later.
.SS "About Search Fingers"
.IX Subsection "About Search Fingers"
A side effect of the search function is that it returns a \fIfinger\fR to
where the key is or should be in the list.
.PP
We can use this finger for future searches if the key that we are
searching for occurs \fIafter\fR the key that produced the finger. For
example,
.PP
.Vb 1
\&  ($value, $finger) = $list\->find(\*(AqTuring\*(Aq);
.Ve
.PP
If we are searching for a key that occurs after 'Turing' in the above
example, then we can use this finger:
.PP
.Vb 1
\&  $value = $list\->find(\*(AqVonNeuman\*(Aq, $finger);
.Ve
.PP
If we use this finger to search for a key that occurs before 'Turing'
however, it may fail:
.PP
.Vb 1
\&  $value = $list\->find(\*(AqGoedel\*(Aq, $finger); # this may not work
.Ve
.PP
Therefore, use search fingers with caution.
.PP
Search fingers are specific to particular instances of a skip list.
The following should not work:
.PP
.Vb 2
\&  ($value1, $finger) = $list1\->find(\*(Aqbar\*(Aq);
\&  $value2            = $list2\->find(\*(Aqfoo\*(Aq, $finger);
.Ve
.PP
One useful feature of fingers is with enumerating all keys using the
\&\*(L"first_key\*(R" and \*(L"next_key\*(R" methods:
.PP
.Vb 1
\&  ($key, $finger) = $list\->first_key;
\&
\&  while (defined $key) {
\&    ...
\&    ($key, $finger) = $list\->next_key($key, $finger);
\&  }
.Ve
.PP
See also the \*(L"keys\*(R" method for generating a list of keys.
.SS "Similarities to Tree Classes"
.IX Subsection "Similarities to Tree Classes"
This module intentionally has a subset of the interface in the
Tree::Base and other tree-type data structure modules, since skip
lists can be used in place of trees.
.PP
Because pointers only point forward, there is no \f(CW\*(C`prev\*(C'\fR method to
point to the previous key.
.PP
Some of these methods (least, greatest) are autoloading because they
are not commonly used.
.PP
One thing that differentiates this module from other modules is the
flexibility in defining a custom node class.
.PP
See the included \fIBenchmark.txt\fR file for performance comparisons.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.IP "Upgrading from List::SkipList" 4
.IX Item "Upgrading from List::SkipList"
If you are upgrading a prior version of List::SkipList, then you
may want to uninstall the module before installing
Algorithm::SkipList, so as to remove unused autoloading files.
.IP "Undefined Values" 4
.IX Item "Undefined Values"
Certain methods such as \*(L"find\*(R" and \*(L"delete\*(R" will return the the
value associated with a key, or \f(CW\*(C`undef\*(C'\fR if the key does not exist.
However, if the value is \f(CW\*(C`undef\*(C'\fR, then these functions will appear to
claim that the key cannot be found.
.Sp
In such circumstances, use the \*(L"exists\*(R" method to test for the
existence of a key.
.IP "Duplicate Keys" 4
.IX Item "Duplicate Keys"
Duplicate keys are an experimental feature in this module, since most
methods have been designed for unique keys only.
.Sp
Access to duplicate keys is akin to a stack.  When a duplicate key is
added, it is always inserted \fIbefore\fR matching keys.  In searches, to
find duplicate keys one must use \*(L"find_with_finger\*(R" or the
\&\*(L"find_duplicates\*(R" method.
.Sp
The \*(L"copy\*(R" method will reverse the order of duplicates.
.Sp
The behavior of the \*(L"merge\*(R" and \*(L"append\*(R" methods is not defined
for duplicates.
.IP "Non-Determinism" 4
.IX Item "Non-Determinism"
Skip lists are non-deterministic.  Because of this, bugs in programs
that use this module may be subtle and difficult to reproduce without
many repeated attempts.  This is especially true if there are bugs in
a custom node.
.PP
Additional issues may be listed on the \s-1CPAN\s0 Request Tracker at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Algorithm\-SkipList> or
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=List\-SkipList>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robert Rothenberg <rrwo at cpan.org>
.SS "Acknowledgements"
.IX Subsection "Acknowledgements"
Carl Shapiro <cshapiro at panix.com> for introduction to skip lists.
.SS "Suggestions and Bug Reporting"
.IX Subsection "Suggestions and Bug Reporting"
Feedback is always welcome.  Please use the \s-1CPAN\s0 Request Tracker at
<http://rt.cpan.org> to submit bug reports.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2003\-2005 Robert Rothenberg. All rights reserved.  This
program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See the article by William Pugh, \*(L"A Skip List Cookbook\*(R" (1989), or
similar ones by the author at <http://www.cs.umd.edu/~pugh/> which
discuss skip lists.
.PP
Another article worth reading is by Bruce Schneier, \*(L"Skip Lists:
They're easy to implement and they work\*(R",
Doctor Dobbs Journal <http://www.ddj.com>, January 1994.
.PP
Tie::Hash::Sorted maintains a hash where keys are sorted.  In many
cases this is faster, uses less memory (because of the way Perl5
manages memory), and may be more appropriate for some uses.
.PP
If you need a keyed list that preserves the order of insertion rather
than sorting keys, see List::Indexed or Tie::IxHash.
